# frozen_string_literal: true

class ValidationBetaService
  def remind_sits_to_add_participants
    empty_school_cohorts = SchoolCohort
                             .where(induction_programme_choice: %i[full_induction_programme core_induction_programme not_yet_known])
                             .where(opt_out_of_updates: false)
                             .where.not(id: ParticipantProfile::ECF.select(:school_cohort_id))

    School.where(id: empty_school_cohorts.select(:school_id)).includes(:induction_coordinators).find_each do |school|
      school.induction_coordinator_profiles.each do |sit|
        next if sit.reminder_email_sent_at.present?

        email = SchoolMailer.remind_induction_coordinator_to_setup_cohort_email(
          recipient: sit.user.email,
          school_name: school.name,
          campaign: :sit_to_complete_steps,
        )

        ActiveRecord::Base.transaction do
          sit.update_column(:reminder_email_sent_at, Time.zone.now)
          email.deliver_later
        end
      end
    end
  end

  # This timestamp was generated by finding the last user with request_for_details_sent_at: nil,
  # after automation this request for details is sent automatically
  AUTOMATION_LAUNCH_TIME = Time.zone.parse("2021-09-17 09:45:33.284979000 +0000").freeze
  VALIDATION_CHASER_BATCH_LIMIT = 5000

  # ECTs who have not added their details for validation
  def tell_ects_to_add_validation_information(limit: VALIDATION_CHASER_BATCH_LIMIT)
    sent = 0
    ParticipantProfile::ECT
      .where(request_for_details_sent_at: nil)
      .or(ParticipantProfile::ECT.where(request_for_details_sent_at: ..AUTOMATION_LAUNCH_TIME))
      .active_record
      .includes(:ecf_participant_eligibility, :ecf_participant_validation_data, :school_cohort, :school, :user)
      .where(
        school_cohort: {
          cohort: Cohort.current,
          induction_programme_choice: %w[core_induction_programme full_induction_programme],
        },
        ecf_participant_eligibility: {
          participant_profile_id: nil,
        },
        ecf_participant_validation_data: {
          participant_profile_id: nil,
        },
      ).find_each do |profile|
        send_ects_to_add_validation_information(profile, profile.school)

        # We cannot use a limit on the sql query because find_each/find_in_batches uses
        # a limit that will override any one we provide
        sent += 1
        break if sent == limit
      end
    Rails.logger.info "Send #{sent} emails to ECTs"
  end

  # mentors who have not added their details for validation
  def tell_mentors_to_add_validation_information(limit: VALIDATION_CHASER_BATCH_LIMIT)
    sent = 0
    ParticipantProfile::Mentor
      .where(request_for_details_sent_at: nil)
      .or(ParticipantProfile::Mentor.where(request_for_details_sent_at: ..AUTOMATION_LAUNCH_TIME))
      .active_record
      .includes(:ecf_participant_eligibility, :ecf_participant_validation_data, :school_cohort, :school, user: :induction_coordinator_profile)
      .where(
        school_cohort: {
          cohort: Cohort.current,
          induction_programme_choice: %w[core_induction_programme full_induction_programme],
        },
        ecf_participant_eligibility: {
          participant_profile_id: nil,
        },
        ecf_participant_validation_data: {
          participant_profile_id: nil,
        },
      )
      .find_each do |profile|
        next if profile.user.induction_coordinator?

        send_mentors_to_add_validation_information(profile, profile.school)

        sent += 1
        break if sent == limit
      end
    Rails.logger.info "Send #{sent} emails to mentors"
  end

  def tell_induction_coordinators_who_are_mentors_to_add_validation_information(limit: VALIDATION_CHASER_BATCH_LIMIT)
    sent = 0
    ParticipantProfile::Mentor
      .where(request_for_details_sent_at: nil)
      .or(ParticipantProfile::Mentor.where(request_for_details_sent_at: ..AUTOMATION_LAUNCH_TIME))
      .active_record
      .includes(:ecf_participant_eligibility, :ecf_participant_validation_data, :school_cohort, :school, user: :induction_coordinator_profile)
      .where(
        school_cohort: {
          cohort: Cohort.current,
        },
        ecf_participant_eligibility: {
          participant_profile_id: nil,
        },
        ecf_participant_validation_data: {
          participant_profile_id: nil,
        },
      ).find_each do |profile|
        next unless profile.user.induction_coordinator?

        send_induction_coordinators_who_are_mentors_to_add_validation_information(profile, profile.school)

        sent += 1
        break if sent == limit
      end
    Rails.logger.info "Send #{sent} emails to SIT mentors"
  end

  def tell_induction_coordinators_we_asked_ects_and_mentors_for_information
    school_cohorts = SchoolCohort
                       .where(
                         id: ParticipantProfile::ECF.where("created_at > ?", Date.new(2021, 9, 7)).select(:school_cohort_id),
                         induction_programme_choice: %w[core_induction_programme full_induction_programme],
                       )

    school_ids = school_cohorts.select(:school_id)

    InductionCoordinatorProfile
      .includes(:schools)
      .where(schools: { id: school_ids })
      .find_each do |ic|
      ic.schools.not_opted_out.where(id: school_ids).find_each do |school|
        if chosen_programme_and_not_in_beta(school)
          send_induction_coordinators_we_asked_ects_and_mentors_for_information(ic, school)
          break
        end
      end
    end
  end

  def set_up_missing_chasers
    participants_yet_to_validate.find_each do |profile|
      next if chaser_scheduled?(profile)

      ParticipantDetailsReminderJob.schedule(profile)
    end
  end

private

  def send_ects_to_add_validation_information(profile, school)
    campaign = :ect_validation_info_2709

    participant_validation_start_url = Rails.application.routes.url_helpers.participants_start_registrations_url(
      host: Rails.application.config.domain,
      **UTMService.email(campaign, campaign),
    )

    email = ParticipantValidationMailer.ects_to_add_validation_information_email(
      recipient: profile.user.email,
      school_name: school.name,
      start_url: participant_validation_start_url,
    )

    ActiveRecord::Base.transaction do
      email.deliver_later
      profile.update_column(:request_for_details_sent_at, Time.zone.now)
    end
  end

  def send_mentors_to_add_validation_information(profile, school)
    campaign = :mentor_validation_info_2709

    participant_validation_start_url = Rails.application.routes.url_helpers.participants_start_registrations_url(
      host: Rails.application.config.domain,
      **UTMService.email(campaign, campaign),
    )

    email = ParticipantValidationMailer.mentors_to_add_validation_information_email(
      recipient: profile.user.email,
      school_name: school.name,
      start_url: participant_validation_start_url,
    )

    ActiveRecord::Base.transaction do
      email.deliver_later
      profile.update_column(:request_for_details_sent_at, Time.zone.now)
    end
  end

  def send_induction_coordinators_who_are_mentors_to_add_validation_information(profile, school)
    campaign = :sit_mentor_validation_info_2709

    participant_validation_start_url = Rails.application.routes.url_helpers.participants_start_registrations_url(
      host: Rails.application.config.domain,
      **UTMService.email(campaign, campaign),
    )

    email = ParticipantValidationMailer.induction_coordinators_who_are_mentors_to_add_validation_information_email(
      recipient: profile.user.email,
      school_name: school.name,
      start_url: participant_validation_start_url,
    )

    ActiveRecord::Base.transaction do
      email.deliver_later
      profile.update_column(:request_for_details_sent_at, Time.zone.now)
    end
  end

  def send_induction_coordinators_we_asked_ects_and_mentors_for_information(induction_coordinator, school)
    campaign = :asked_ects_and_mentors_for_information

    sign_in_url = Rails.application.routes.url_helpers.new_user_session_url(
      host: Rails.application.config.domain,
      **UTMService.email(campaign, campaign),
    )

    ParticipantValidationMailer.induction_coordinators_we_asked_ects_and_mentors_for_information_email(
      recipient: induction_coordinator.user.email,
      school_name: school.name,
      sign_in: sign_in_url,
    ).deliver_later
  end

  def chosen_programme_and_not_in_beta(school)
    !FeatureFlag.active?(:participant_validation, for: school) && school.chosen_programme?(Cohort.current)
  end

  def participants_yet_to_validate
    ParticipantProfile::ECF
      .ecf
      .active_record
      .includes(:ecf_participant_eligibility, :ecf_participant_validation_data, :school_cohort)
      .where(
        school_cohort: {
          cohort: Cohort.current,
          induction_programme_choice: %w[core_induction_programme full_induction_programme],
        },
        ecf_participant_eligibility: {
          participant_profile_id: nil,
        },
        ecf_participant_validation_data: {
          participant_profile_id: nil,
        },
      )
  end

  def chaser_scheduled?(profile)
    Delayed::Job.where("handler ILIKE ?", "%ParticipantDetailsReminderJob%#{profile.id}%").exists?
  end
end
